<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>NO TIME HOLE</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,-apple-system,"Segoe UI",sans-serif;}
    canvas{position:fixed;inset:0;width:100%;height:100%}

    .controls{
      position:fixed;left:14px;top:14px;z-index:6;
      display:flex;gap:10px;align-items:center;
      pointer-events:auto;
      opacity:.72;
      transition:opacity .25s ease;
    }
    .controls:hover{opacity:1}
    button{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.88);
      border-radius:14px;
      padding:10px 12px;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(10px);
    }
    button:active{transform:translateY(1px)}

    .overlay{
      position:fixed;inset:0;pointer-events:none;
      display:grid;place-items:center;padding:24px;
      color:rgba(255,255,255,.88);
      text-align:center;
    }
    .box{
      max-width:760px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.28);
      backdrop-filter: blur(10px);
      border-radius:22px;
      padding:18px 18px 16px;
      box-shadow: 0 12px 60px rgba(0,0,0,.45);
    }
    .big{font-weight:900;letter-spacing:.04em;font-size:clamp(18px,3vw,30px);line-height:1.25;margin-bottom:10px}
    .small{font-size:clamp(12px,1.7vw,14px);color:rgba(255,255,255,.70);line-height:1.8}
    .overlay.fade{opacity:0;transition:opacity 1.2s ease}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="controls">
    <button id="enter">入る</button>
    <button id="vanish">言葉を消す</button>
  </div>

  <div class="overlay" id="overlay">
    <div class="box">
      <div class="big">ここには、過去も未来もない。</div>
      <div class="small">
        中央に近づくほど、銀河の“輪郭”がほどけていく。<br/>
        何かをしなくていい。ただ、居てください。
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  let W=0,H=0,DPR=1;
  const sky = document.createElement("canvas");
  const sctx = sky.getContext("2d");

  // pointer
  let px=0.5, py=0.5, spx=0.5, spy=0.5;
  addEventListener("pointermove", e=>{
    px = e.clientX / innerWidth;
    py = e.clientY / innerHeight;
  }, {passive:true});

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function smoothstep(a,b,t){
    t = clamp((t-a)/(b-a), 0, 1);
    return t*t*(3-2*t);
  }
  function lerp(a,b,t){ return a + (b-a)*t; }

  // Deterministic-ish hash noise
  function hash2(x,y){
    const s = Math.sin(x*127.1 + y*311.7) * 43758.5453123;
    return s - Math.floor(s);
  }

  // Star color temperature mix (blue-white / white / yellow / red)
  function starRGB(k){
    if(k < 0.22) return [200,220,255];
    if(k < 0.55) return [245,245,255];
    if(k < 0.86) return [255,240,210];
    return [255,210,195];
  }

  // Galactic plane parameters
  let m = -0.25;      // tilt slope
  let cx0 = 0, cy0 = 0;
  let bandWidth = 0;

  // Layers
  const starsFar = [];
  const starsNear = [];
  const dust = [];        // micro stars in band
  const darkLanes = [];   // dust lanes (dark)
  const nebulae = [];     // colorful glows
  const clusters = [];    // star clusters

  function resize(){
    DPR = Math.max(1, Math.min(2, devicePixelRatio || 1));
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;

    sky.width = W; sky.height = H;

    cx0 = W*0.52;
    cy0 = H*0.52;
    bandWidth = Math.min(W,H)*0.24;

    buildGalaxy();
  }
  addEventListener("resize", resize);

  function bandCenterY(x){
    // warped galactic plane
    const warp = Math.sin(x*0.0038)*bandWidth*0.10 + Math.sin(x*0.0014)*bandWidth*0.06;
    return m*(x - cx0) + cy0 + warp;
  }

  function bandDensity(x,y){
    const yLine = bandCenterY(x);
    const d = Math.abs(y - yLine);
    // stronger core near center of screen, like looking toward bulge
    const bulge = 1 - smoothstep(0, Math.min(W,H)*0.55, Math.hypot(x-cx0, y-cy0));
    const band = 1 - smoothstep(0, bandWidth, d);
    return clamp(0.18 + 0.82*(band*band*0.9 + bulge*0.35), 0, 1);
  }

  function buildGalaxy(){
    starsFar.length=0; starsNear.length=0; dust.length=0;
    darkLanes.length=0; nebulae.length=0; clusters.length=0;

    // Base deep space
    sctx.setTransform(1,0,0,1,0,0);
    const bg = sctx.createRadialGradient(W/2,H/2,0, W/2,H/2, Math.max(W,H)*0.95);
    bg.addColorStop(0, "rgb(7,8,14)");
    bg.addColorStop(1, "rgb(0,0,0)");
    sctx.fillStyle = bg;
    sctx.fillRect(0,0,W,H);

    // Nebulae (color glows along/around the band)
    const nebCount = 14;
    for(let i=0;i<nebCount;i++){
      const u = i/(nebCount-1);
      const x = W*(0.10 + 0.80*u) + (Math.random()*2-1)*W*0.05;
      const y = bandCenterY(x) + (Math.random()*2-1)*bandWidth*0.55;

      // pick palette: blue/cyan, purple, magenta/red
      const p = Math.random();
      const col = p < 0.45 ? [110,170,255] : (p < 0.75 ? [190,130,255] : [255,120,170]);
      nebulae.push({
        x,y,
        r: (0.14 + Math.random()*0.22) * Math.min(W,H),
        a: 0.05 + Math.random()*0.11,
        col
      });
    }

    // draw nebula base
    sctx.save();
    sctx.globalCompositeOperation = "screen";
    for(const n of nebulae){
      const g = sctx.createRadialGradient(n.x,n.y,0, n.x,n.y,n.r);
      g.addColorStop(0, `rgba(${n.col[0]},${n.col[1]},${n.col[2]},${n.a})`);
      g.addColorStop(1, "rgba(0,0,0,0)");
      sctx.fillStyle = g;
      sctx.fillRect(n.x-n.r, n.y-n.r, n.r*2, n.r*2);
    }
    sctx.restore();

    // Dark dust lanes (important for “銀河っぽさ”)
    const laneCount = 18;
    for(let i=0;i<laneCount;i++){
      const u = i/(laneCount-1);
      const x = W*(0.08 + 0.84*u);
      const y = bandCenterY(x) + (Math.random()*2-1)*bandWidth*0.18;
      darkLanes.push({
        x,y,
        r: (0.10 + Math.random()*0.20) * Math.min(W,H),
        a: 0.10 + Math.random()*0.16
      });
    }

    // Lay down a bright milky way haze (micro texture)
    // We do it by painting many tiny semi-transparent points with density near band.
    const hazeCount = Math.floor((W*H)/520);
    sctx.save();
    sctx.globalCompositeOperation = "screen";
    for(let i=0;i<hazeCount;i++){
      const x = Math.random()*W;
      const y = Math.random()*H;
      const d = bandDensity(x,y);
      if(Math.random() > d) continue;

      // bluish-white haze
      const a = (0.02 + 0.14*Math.random()) * d;
      sctx.fillStyle = `rgba(210,225,255,${a})`;
      const s = (0.7 + Math.random()*1.5) * DPR;
      sctx.fillRect(x,y,s,s);
    }
    sctx.restore();

    // Apply dark lanes on top to carve the band
    sctx.save();
    sctx.globalCompositeOperation = "multiply";
    for(const dl of darkLanes){
      const g = sctx.createRadialGradient(dl.x,dl.y,0, dl.x,dl.y,dl.r);
      g.addColorStop(0, `rgba(0,0,0,${dl.a})`);
      g.addColorStop(1, "rgba(0,0,0,0)");
      sctx.fillStyle = g;
      sctx.fillRect(dl.x-dl.r, dl.y-dl.r, dl.r*2, dl.r*2);
    }
    sctx.restore();

    // Star clusters (星団) — これが銀河感に効く
    const clusterCount = 6;
    for(let i=0;i<clusterCount;i++){
      const x = W*(0.18 + Math.random()*0.64);
      const y = bandCenterY(x) + (Math.random()*2-1)*bandWidth*0.28;
      clusters.push({
        x,y,
        r: (0.06 + Math.random()*0.10) * Math.min(W,H),
        n: Math.floor(120 + Math.random()*260)
      });
    }

    // Build far stars (many, small; more near band)
    const farCount = Math.floor((W*H)/3600);
    for(let i=0;i<farCount;i++){
      const x = Math.random()*W;
      const y = Math.random()*H;
      const d = bandDensity(x,y);

      // still stars outside band, but fewer
      if(Math.random() > (0.30 + 0.70*d)) continue;

      const k = Math.random();
      const [r,g,b] = starRGB(k);
      starsFar.push({
        x,y,
        s: (0.6 + Math.random()*1.5) * DPR,
        a: 0.10 + 0.55*Math.random(),
        r,g,b,
        ph: Math.random()*Math.PI*2,
        tw: 0.3 + Math.random()*1.6
      });
    }

    // Near stars (brighter + glow)
    const nearCount = Math.floor((W*H)/12000);
    for(let i=0;i<nearCount;i++){
      const x = Math.random()*W;
      const y = Math.random()*H;
      const d = bandDensity(x,y);
      if(Math.random() > (0.22 + 0.78*d)) continue;

      const k = Math.random();
      const [r,g,b] = starRGB(k);
      starsNear.push({
        x,y,
        s: (1.2 + Math.random()*3.2) * DPR,
        a: 0.28 + 0.62*Math.random(),
        r,g,b,
        glow: (8 + Math.random()*22) * DPR,
        ph: Math.random()*Math.PI*2,
        tw: 0.25 + Math.random()*1.1
      });
    }

    // Cluster stars
    for(const c of clusters){
      for(let i=0;i<c.n;i++){
        const ang = Math.random()*Math.PI*2;
        const rr = Math.pow(Math.random(), 0.35) * c.r; // denser core
        const x = c.x + Math.cos(ang)*rr;
        const y = c.y + Math.sin(ang)*rr;

        const k = Math.random();
        const [r,g,b] = starRGB(k);
        dust.push({
          x,y,
          s: (0.7 + Math.random()*1.6) * DPR,
          a: 0.08 + 0.30*Math.random(),
          r,g,b
        });
      }
    }

    // Render static sky base (far + dust + near)
    sctx.save();
    sctx.globalCompositeOperation = "screen";

    // far
    for(const st of starsFar){
      sctx.fillStyle = `rgba(${st.r},${st.g},${st.b},${st.a})`;
      sctx.fillRect(st.x, st.y, st.s, st.s);
    }

    // cluster/dust points
    for(const d of dust){
      sctx.fillStyle = `rgba(${d.r},${d.g},${d.b},${d.a})`;
      sctx.fillRect(d.x, d.y, d.s, d.s);
    }

    // near with glow
    for(const st of starsNear){
      const g = sctx.createRadialGradient(st.x,st.y,0, st.x,st.y,st.glow);
      g.addColorStop(0, `rgba(${st.r},${st.g},${st.b},${0.12*st.a})`);
      g.addColorStop(1, "rgba(0,0,0,0)");
      sctx.fillStyle = g;
      sctx.fillRect(st.x-st.glow, st.y-st.glow, st.glow*2, st.glow*2);

      sctx.fillStyle = `rgba(${st.r},${st.g},${st.b},${st.a})`;
      sctx.fillRect(st.x, st.y, st.s, st.s);
    }

    sctx.restore();
  }

  // --------- Main draw (adds parallax + lens + horizon) ----------
  let phase = 0;
  function draw(){
    spx += (px-spx)*0.05;
    spy += (py-spy)*0.05;

    const centerX = W/2, centerY = H/2;
    const dx = (spx-0.5)*2;
    const dy = (spy-0.5)*2;
    const dist = Math.min(1, Math.hypot(dx,dy));
    const pull = 1 - dist;       // 0..1
    const p = Math.pow(Math.max(0,pull), 1.35);

    // base sky
    ctx.setTransform(1,0,0,1,0,0);
    ctx.drawImage(sky, 0, 0);

    // parallax drift
    phase += 0.004 + Math.sin(phase*0.77)*0.0008;

    const parX = (spx-0.5) * DPR;
    const parY = (spy-0.5) * DPR;

    // subtle shimmer (tiny, non-rhythmic)
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    for(const st of starsNear){
      const tw = (0.5 + 0.5*Math.sin(phase*st.tw + st.ph));
      const a = 0.06 * tw;
      if(a <= 0) continue;
      ctx.fillStyle = `rgba(${st.r},${st.g},${st.b},${a})`;
      ctx.fillRect(st.x + parX*7, st.y + parY*7, st.s, st.s);
    }
    ctx.restore();

    // pseudo gravitational lensing (warped region copy)
    const lensStrength = 0.16 + 0.62*p;
    const lensR = Math.min(W,H) * (0.26 + 0.16*p);

    ctx.save();
    ctx.globalAlpha = 0.55 * (0.25 + 0.75*p);
    ctx.globalCompositeOperation = "screen";
    const sx = centerX - lensR, sy = centerY - lensR, sw = lensR*2, sh = lensR*2;
    for(let i=0;i<6;i++){
      const k = (i+1)/6;
      const scale = 1 - lensStrength * (0.11 + 0.20*k);
      ctx.setTransform(1,0,0,1,0,0);
      ctx.translate(centerX, centerY);
      ctx.scale(scale, scale);
      ctx.translate(-centerX, -centerY);
      ctx.drawImage(sky, sx, sy, sw, sh, sx, sy, sw, sh);
    }
    ctx.restore();
    ctx.setTransform(1,0,0,1,0,0);

    // event horizon ring (slightly brighter = “銀河背景で映える”)
    const rH = Math.min(W,H) * (0.055 + 0.072*p);
    const ring = ctx.createRadialGradient(centerX, centerY, rH*0.22, centerX, centerY, rH*3.2);
    ring.addColorStop(0, "rgba(0,0,0,1)");
    ring.addColorStop(0.56, "rgba(0,0,0,1)");
    ring.addColorStop(0.80, `rgba(200,220,255,${0.10 + 0.55*p})`);
    ring.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = ring;
    ctx.beginPath();
    ctx.arc(centerX, centerY, rH*3.2, 0, Math.PI*2);
    ctx.fill();

    // inner hole
    ctx.fillStyle = "rgba(0,0,0,1)";
    ctx.beginPath();
    ctx.arc(centerX, centerY, rH*0.95, 0, Math.PI*2);
    ctx.fill();

    // vignette (space exposure falloff)
    const vg = ctx.createRadialGradient(centerX, centerY, Math.min(W,H)*0.12, centerX, centerY, Math.max(W,H)*0.88);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(0.55, `rgba(0,0,0,${0.10 + 0.30*p})`);
    vg.addColorStop(1, `rgba(0,0,0,${0.60 + 0.26*p})`);
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);

    requestAnimationFrame(draw);
  }

  // UI
  const overlay = document.getElementById("overlay");
  document.getElementById("enter").addEventListener("click", ()=>{
    overlay.classList.add("fade");
    setTimeout(()=>{ overlay.style.display="none"; }, 1400);
  });
  document.getElementById("vanish").addEventListener("click", ()=>{
    overlay.classList.add("fade");
    setTimeout(()=>{ overlay.style.display="none"; }, 1400);
  });

  // start
  resize();
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
