<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>NO TIME HOLE</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,-apple-system,"Segoe UI",sans-serif;}
    canvas{position:fixed;inset:0;width:100%;height:100%}
    .overlay{
      position:fixed;inset:0;pointer-events:none;
      display:grid;place-items:center;padding:24px;
      color:rgba(255,255,255,.88);
      text-align:center;
    }
    .box{
      max-width:760px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.28);
      backdrop-filter: blur(10px);
      border-radius:22px;
      padding:18px 18px 16px;
      box-shadow: 0 12px 60px rgba(0,0,0,.45);
    }
    .big{font-weight:900;letter-spacing:.04em;font-size:clamp(18px,3vw,30px);line-height:1.25;margin-bottom:10px}
    .small{font-size:clamp(12px,1.7vw,14px);color:rgba(255,255,255,.70);line-height:1.8}
    .controls{
      position:fixed;left:16px;top:16px;z-index:5;
      display:flex;gap:10px;align-items:center;
      pointer-events:auto;
      opacity:.72;
      transition:opacity .25s ease;
    }
    .controls:hover{opacity:1}
    button{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.88);
      border-radius:14px;
      padding:10px 12px;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(10px);
    }
    button:active{transform:translateY(1px)}
    .overlay.fade{opacity:0;transition:opacity 1.2s ease}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="controls">
    <button id="enter">入る</button>
    <button id="silence">無音</button>
    <button id="vanish">言葉を消す</button>
  </div>

  <div class="overlay" id="overlay">
    <div class="box">
      <div class="big">ここには、過去も未来もない。</div>
      <div class="small">
        宇宙は均一ではない。星は帯を成し、塵は光を散らす。<br/>
        中央に近づくほど、輪郭が溶けていきます。<br/>
        <span style="opacity:.9">（イヤホン推奨 / 音は「入る」で有効）</span>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha:false });

    let W=0,H=0,DPR=1;
    function resize(){
      DPR = Math.max(1, Math.min(2, devicePixelRatio || 1));
      W = Math.floor(innerWidth * DPR);
      H = Math.floor(innerHeight * DPR);
      canvas.width = W; canvas.height = H;
      buildSky();
    }
    addEventListener("resize", resize);

    // Pointer
    let px=0.5, py=0.5, spx=0.5, spy=0.5;
    addEventListener("pointermove", e=>{
      px = e.clientX / innerWidth;
      py = e.clientY / innerHeight;
    }, {passive:true});

    // ---------- Audio (optional, timeless) ----------
    let audioCtx, master, lp, osc1, osc2, noiseSrc, noiseGain;
    let audioOn=false, muted=false;

    function pinkishNoiseBuffer(ctx, seconds=2){
      const sr = ctx.sampleRate, len = Math.floor(sr*seconds);
      const buf = ctx.createBuffer(1, len, sr);
      const data = buf.getChannelData(0);
      let last = 0;
      for(let i=0;i<len;i++){
        const white = (Math.random()*2-1);
        last = (last + 0.02*white) / 1.02;
        data[i] = last * 2.5;
      }
      return buf;
    }
    async function setupAudio(){
      if(audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      master = audioCtx.createGain(); master.gain.value = 0;
      lp = audioCtx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=900;
      osc1 = audioCtx.createOscillator(); osc1.type="sine"; osc1.frequency.value=72;
      osc2 = audioCtx.createOscillator(); osc2.type="triangle"; osc2.frequency.value=36;
      const g1 = audioCtx.createGain(); g1.gain.value=0.10;
      const g2 = audioCtx.createGain(); g2.gain.value=0.08;

      noiseSrc = audioCtx.createBufferSource();
      noiseSrc.buffer = pinkishNoiseBuffer(audioCtx, 2.5);
      noiseSrc.loop = true;
      noiseGain = audioCtx.createGain(); noiseGain.gain.value=0.06;

      osc1.connect(g1); osc2.connect(g2);
      g1.connect(lp); g2.connect(lp);
      noiseSrc.connect(noiseGain); noiseGain.connect(lp);
      lp.connect(master); master.connect(audioCtx.destination);

      const lfo = audioCtx.createOscillator(); lfo.type="sine"; lfo.frequency.value=0.03;
      const lfoGain = audioCtx.createGain(); lfoGain.gain.value=4.0;
      lfo.connect(lfoGain);
      lfoGain.connect(osc1.detune);
      lfoGain.connect(osc2.detune);

      osc1.start(); osc2.start(); noiseSrc.start(); lfo.start();
    }
    async function enterAudio(){
      await setupAudio();
      await audioCtx.resume();
      audioOn=true;
      master.gain.cancelScheduledValues(audioCtx.currentTime);
      master.gain.linearRampToValueAtTime(muted ? 0 : 0.9, audioCtx.currentTime + 0.8);
    }
    function toggleMute(){
      muted = !muted;
      document.getElementById("silence").textContent = muted ? "音あり" : "無音";
      if(audioCtx && master){
        master.gain.cancelScheduledValues(audioCtx.currentTime);
        master.gain.linearRampToValueAtTime(muted ? 0 : (audioOn ? 0.9 : 0), audioCtx.currentTime + 0.25);
      }
    }

    // ---------- Procedural “more realistic space” ----------
    // Build a static sky texture once (stars + milky way + nebula haze), then animate subtly.
    const sky = document.createElement("canvas");
    const sctx = sky.getContext("2d");
    let skyReady = false;

    // Star catalogs (layers for parallax)
    const starsNear = [];
    const starsFar  = [];
    const dustPts   = []; // milky way micro stars / dust specks
    const glowBlobs = []; // nebula-like haze blobs

    function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

    // Deterministic-ish hash noise
    function hash2(x,y){
      const s = Math.sin(x*127.1 + y*311.7) * 43758.5453123;
      return s - Math.floor(s); // 0..1
    }
    function smoothstep(a,b,t){
      t = clamp((t-a)/(b-a), 0, 1);
      return t*t*(3-2*t);
    }

    function tempColor(k){ // approximate star color from “temperature bucket”
      // return [r,g,b] 0..255
      // 0: cool blue-white, 1: neutral white, 2: warm yellow, 3: orange-red
      if(k < 0.25) return [210,225,255];
      if(k < 0.55) return [245,245,255];
      if(k < 0.85) return [255,240,210];
      return [255,210,190];
    }

    function buildSky(){
      sky.width = W;
      sky.height = H;
      sctx.clearRect(0,0,W,H);

      starsNear.length = 0;
      starsFar.length  = 0;
      dustPts.length   = 0;
      glowBlobs.length = 0;

      // Background base (deep space gradient)
      const gx=W/2, gy=H/2;
      const bg = sctx.createRadialGradient(gx,gy,0,gx,gy,Math.max(W,H)*0.9);
      bg.addColorStop(0, "rgb(7,8,14)");
      bg.addColorStop(1, "rgb(0,0,0)");
      sctx.fillStyle = bg;
      sctx.fillRect(0,0,W,H);

      // Milky Way band: define a tilted “galactic plane”
      // band center line: y = m(x - cx) + cy + warp
      const m = -0.28; // tilt
      const cx0 = W*0.52, cy0 = H*0.52;
      const bandWidth = Math.min(W,H) * 0.22;

      // Nebula haze blobs (broad soft glows along the band)
      const blobCount = 22;
      for(let i=0;i<blobCount;i++){
        const u = i/(blobCount-1);
        const x = W*(0.12 + 0.76*u) + (Math.random()*2-1)*W*0.04;
        const yLine = m*(x - cx0) + cy0;
        const y = yLine + (Math.random()*2-1)*bandWidth*0.35;
        glowBlobs.push({
          x,y,
          r: (0.12 + Math.random()*0.22) * Math.min(W,H),
          a: 0.05 + Math.random()*0.12,
          tint: Math.random()
        });
      }

      // Draw haze blobs
      for(const b of glowBlobs){
        const g = sctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r);
        const t = b.tint;
        // subtle bluish/purplish haze like long-exposure
        const c1 = t<0.5 ? [120,160,255] : [190,130,255];
        g.addColorStop(0, `rgba(${c1[0]},${c1[1]},${c1[2]},${b.a})`);
        g.addColorStop(1, `rgba(0,0,0,0)`);
        sctx.fillStyle = g;
        sctx.fillRect(0,0,W,H);
      }

      // Micro dust stars within milky way (dense, small)
      const dustCount = Math.floor((W*H)/900); // scales with screen
      for(let i=0;i<dustCount;i++){
        const x = Math.random()*W;
        const y = Math.random()*H;

        // distance to band center line
        const yLine = m*(x - cx0) + cy0 + Math.sin(x*0.004)*bandWidth*0.12;
        const d = Math.abs(y - yLine);

        // density: highest near band, quickly falls off
        const band = 1 - smoothstep(0, bandWidth, d);
        if(Math.random() > band*band) continue;

        dustPts.push({
          x,y,
          s: (0.6 + Math.random()*1.6) * DPR,
          a: 0.05 + 0.25*band*Math.random()
        });
      }

      // Big stars: far layer (many small)
      const farCount = Math.floor((W*H)/4200);
      for(let i=0;i<farCount;i++){
        const x = Math.random()*W;
        const y = Math.random()*H;

        // Slightly more likely near milky way but still everywhere
        const yLine = m*(x - cx0) + cy0;
        const d = Math.abs(y - yLine);
        const band = 0.35 + 0.65*(1 - smoothstep(0, bandWidth*1.6, d));

        if(Math.random() > band) continue;

        const k = Math.random();
        const [r,g,b] = tempColor(k);
        starsFar.push({
          x,y,
          s: (0.7 + Math.random()*1.8) * DPR,
          a: 0.12 + 0.55*Math.random(),
          r,g,b,
          tw: 0.6 + Math.random()*1.6, // twinkle factor
          ph: Math.random()*Math.PI*2,
        });
      }

      // Near stars: fewer but brighter + soft glow
      const nearCount = Math.floor((W*H)/14000);
      for(let i=0;i<nearCount;i++){
        const x = Math.random()*W;
        const y = Math.random()*H;

        const yLine = m*(x - cx0) + cy0;
        const d = Math.abs(y - yLine);
        const band = 0.25 + 0.75*(1 - smoothstep(0, bandWidth*1.2, d));
        if(Math.random() > band) continue;

        const k = Math.random();
        const [r,g,b] = tempColor(k);
        starsNear.push({
          x,y,
          s: (1.2 + Math.random()*3.4) * DPR,
          a: 0.35 + 0.55*Math.random(),
          r,g,b,
          glow: (6 + Math.random()*18) * DPR,
          tw: 0.5 + Math.random()*1.2,
          ph: Math.random()*Math.PI*2,
        });
      }

      // Render static base (dust + far + near) into sky canvas
      // Dust
      sctx.save();
      sctx.globalCompositeOperation = "screen";
      for(const d of dustPts){
        sctx.fillStyle = `rgba(255,255,255,${d.a})`;
        sctx.fillRect(d.x, d.y, d.s, d.s);
      }
      sctx.restore();

      // Far stars
      sctx.save();
      sctx.globalCompositeOperation = "screen";
      for(const st of starsFar){
        sctx.fillStyle = `rgba(${st.r},${st.g},${st.b},${st.a})`;
        sctx.fillRect(st.x, st.y, st.s, st.s);
      }
      sctx.restore();

      // Near stars (with glow)
      sctx.save();
      sctx.globalCompositeOperation = "screen";
      for(const st of starsNear){
        // glow
        const g = sctx.createRadialGradient(st.x,st.y,0,st.x,st.y,st.glow);
        g.addColorStop(0, `rgba(${st.r},${st.g},${st.b},${0.12*st.a})`);
        g.addColorStop(1, `rgba(0,0,0,0)`);
        sctx.fillStyle = g;
        sctx.fillRect(st.x-st.glow, st.y-st.glow, st.glow*2, st.glow*2);

        // core
        sctx.fillStyle = `rgba(${st.r},${st.g},${st.b},${st.a})`;
        sctx.fillRect(st.x, st.y, st.s, st.s);
      }
      sctx.restore();

      skyReady = true;
    }

    // ---------- Main render ----------
    let ph = 0;
    function draw(){
      spx += (px-spx)*0.05;
      spy += (py-spy)*0.05;

      const centerX = W/2, centerY = H/2;
      const dx = (spx-0.5)*2;
      const dy = (spy-0.5)*2;
      const dist = Math.min(1, Math.hypot(dx,dy));
      const pull = 1 - dist;         // 0..1
      const p = Math.pow(Math.max(0,pull), 1.35);

      // base sky
      if(skyReady) ctx.drawImage(sky, 0, 0);

      // subtle twinkle (no rhythmic tempo; quasi drift)
      ph += 0.004 + Math.sin(ph*0.77)*0.0008;

      // Parallax: shift layers a tiny bit based on pointer (like looking around)
      const parX = (spx-0.5) * DPR;
      const parY = (spy-0.5) * DPR;

      // draw twinkles for near stars only (tiny shimmer)
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      for(const st of starsNear){
        const tw = (0.5 + 0.5*Math.sin(ph*st.tw + st.ph));
        const a = 0.08 * tw;
        if(a <= 0) continue;
        ctx.fillStyle = `rgba(${st.r},${st.g},${st.b},${a})`;
        const x = st.x + parX*6;
        const y = st.y + parY*6;
        ctx.fillRect(x, y, st.s, st.s);
      }
      ctx.restore();

      // ---- Black hole effect: event horizon + vignette + pseudo lensing ----
      // Pseudo lensing: draw sky again slightly warped around center (cheap approximation)
      // We sample by scaling a small region toward center to mimic bending.
      const lensStrength = 0.18 + 0.55*p;
      const lensR = Math.min(W,H) * (0.22 + 0.18*p);

      if(skyReady){
        ctx.save();
        ctx.globalAlpha = 0.55 * (0.35 + 0.65*p);
        ctx.globalCompositeOperation = "screen";

        // copy a region around center and scale inward (creates “sucked light” look)
        const sx = centerX - lensR;
        const sy = centerY - lensR;
        const sw = lensR*2;
        const sh = lensR*2;

        // draw multiple rings for smoother warp
        for(let i=0;i<5;i++){
          const k = (i+1)/5;
          const scale = 1 - lensStrength * (0.12 + 0.18*k);
          ctx.setTransform(1,0,0,1,0,0);
          ctx.translate(centerX, centerY);
          ctx.scale(scale, scale);
          ctx.translate(-centerX, -centerY);
          ctx.drawImage(sky, sx, sy, sw, sh, sx, sy, sw, sh);
        }
        ctx.restore();
        ctx.setTransform(1,0,0,1,0,0);
      }

      // event horizon
      const rH = Math.min(W,H) * (0.055 + 0.070*p);
      const ring = ctx.createRadialGradient(centerX, centerY, rH*0.22, centerX, centerY, rH*3.0);
      ring.addColorStop(0, "rgba(0,0,0,1)");
      ring.addColorStop(0.56, "rgba(0,0,0,1)");
      ring.addColorStop(0.84, `rgba(190,210,255,${0.10 + 0.48*p})`);
      ring.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = ring;
      ctx.beginPath();
      ctx.arc(centerX, centerY, rH*3.1, 0, Math.PI*2);
      ctx.fill();

      // inner darkness (true “hole”)
      ctx.fillStyle = "rgba(0,0,0,1)";
      ctx.beginPath();
      ctx.arc(centerX, centerY, rH*0.92, 0, Math.PI*2);
      ctx.fill();

      // vignette (space exposure falloff)
      const vg = ctx.createRadialGradient(centerX, centerY, Math.min(W,H)*0.12, centerX, centerY, Math.max(W,H)*0.85);
      vg.addColorStop(0, "rgba(0,0,0,0)");
      vg.addColorStop(0.55, `rgba(0,0,0,${0.12 + 0.28*p})`);
      vg.addColorStop(1, `rgba(0,0,0,${0.62 + 0.26*p})`);
      ctx.fillStyle = vg;
      ctx.fillRect(0,0,W,H);

      // audio darkens near center (still non-rhythmic)
      if(audioCtx && audioOn){
        const f = 1100*(0.35 + 0.65*(1-p));
        lp.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.20);
      }

      requestAnimationFrame(draw);
    }

    // ---------- UI ----------
    const overlay = document.getElementById("overlay");
    document.getElementById("enter").addEventListener("click", async ()=>{
      await enterAudio();
      overlay.classList.add("fade");
      setTimeout(()=>{ overlay.style.display="none"; }, 1400);
    });
    document.getElementById("silence").addEventListener("click", toggleMute);
    document.getElementById("vanish").addEventListener("click", ()=>{
      overlay.classList.add("fade");
      setTimeout(()=>{ overlay.style.display="none"; }, 1400);
    });

    // start
    resize();
    requestAnimationFrame(draw);
  })();
  </script>
</body>
</html>
