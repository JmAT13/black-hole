<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>NO TIME HOLE</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,-apple-system,"Segoe UI",sans-serif;}
    canvas{position:fixed;inset:0;width:100%;height:100%}

    /* minimal overlay */
    .overlay{
      position:fixed;inset:0;pointer-events:none;
      display:grid;place-items:center;padding:24px;
      color:rgba(255,255,255,.88);
      text-align:center;
      mix-blend-mode:screen;
    }
    .box{
      max-width:720px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.28);
      backdrop-filter: blur(10px);
      border-radius:22px;
      padding:18px 18px 16px;
      box-shadow: 0 12px 60px rgba(0,0,0,.45);
    }
    .big{
      font-weight:900;
      letter-spacing:.04em;
      font-size:clamp(18px,3vw,30px);
      line-height:1.25;
      margin-bottom:10px;
    }
    .small{
      font-size:clamp(12px,1.7vw,14px);
      color:rgba(255,255,255,.70);
      line-height:1.8;
    }

    /* controls (almost hidden) */
    .controls{
      position:fixed;left:16px;top:16px;z-index:5;
      display:flex;gap:10px;align-items:center;
      pointer-events:auto;
      opacity:.72;
      transition:opacity .25s ease;
    }
    .controls:hover{opacity:1}
    button{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.88);
      border-radius:14px;
      padding:10px 12px;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(10px);
    }
    button:active{transform:translateY(1px)}
    .hint{
      position:fixed;right:14px;bottom:12px;z-index:5;
      pointer-events:none;
      font-size:12px;color:rgba(255,255,255,.55);
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.20);
      border-radius:999px;padding:6px 10px;
      backdrop-filter: blur(10px);
      opacity:.85;
    }

    /* fade text away */
    .overlay.fade{opacity:0;transition:opacity 1.2s ease}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="controls">
    <button id="enter">入る</button>
    <button id="silence">無音</button>
    <button id="vanish">言葉を消す</button>
  </div>

  <div class="overlay" id="overlay">
    <div class="box">
      <div class="big">ここには、過去も未来もない。</div>
      <div class="small">
        何かを“しよう”としなくていい。<br/>
        ただ、中央に近づいて、しばらく居てください。<br/>
        <span style="opacity:.9">（イヤホン推奨 / 音は「入る」で有効）</span>
      </div>
    </div>
  </div>

  <div class="hint">中央へ。ゆっくり。</div>

  <script>
    // --- Canvas setup ---
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha:false });

    let W=0,H=0,DPR=1;
    function resize(){
      DPR = Math.max(1, Math.min(2, devicePixelRatio || 1));
      W = Math.floor(innerWidth * DPR);
      H = Math.floor(innerHeight * DPR);
      canvas.width = W; canvas.height = H;
    }
    addEventListener("resize", resize);
    resize();

    // Pointer (no numbers shown, no “progress” UI)
    let px=0.5, py=0.5, spx=0.5, spy=0.5;
    addEventListener("pointermove", e=>{
      px = e.clientX / innerWidth;
      py = e.clientY / innerHeight;
    }, {passive:true});

    // --- Audio (timeless ambience; no tempo cues) ---
    let audioCtx, master, lp, osc1, osc2, noiseSrc, noiseGain;
    let audioOn = false;
    let muted = false;

    function pinkishNoiseBuffer(ctx, seconds=2){
      const sr = ctx.sampleRate;
      const len = Math.floor(sr*seconds);
      const buf = ctx.createBuffer(1, len, sr);
      const data = buf.getChannelData(0);
      // simple brown-ish noise (feels like “space wind”)
      let last = 0;
      for(let i=0;i<len;i++){
        const white = (Math.random()*2-1);
        last = (last + 0.02*white) / 1.02;
        data[i] = last * 2.5;
      }
      return buf;
    }

    async function setupAudio(){
      if(audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      master = audioCtx.createGain();
      master.gain.value = 0;

      lp = audioCtx.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 900;

      // drones (no beat, no BPM)
      osc1 = audioCtx.createOscillator();
      osc1.type = "sine";
      osc1.frequency.value = 72;

      osc2 = audioCtx.createOscillator();
      osc2.type = "triangle";
      osc2.frequency.value = 36;

      const g1 = audioCtx.createGain(); g1.gain.value = 0.10;
      const g2 = audioCtx.createGain(); g2.gain.value = 0.08;

      // noise
      noiseSrc = audioCtx.createBufferSource();
      noiseSrc.buffer = pinkishNoiseBuffer(audioCtx, 2.5);
      noiseSrc.loop = true;
      noiseGain = audioCtx.createGain();
      noiseGain.gain.value = 0.06;

      // routing
      osc1.connect(g1); osc2.connect(g2);
      g1.connect(lp); g2.connect(lp);
      noiseSrc.connect(noiseGain); noiseGain.connect(lp);
      lp.connect(master);
      master.connect(audioCtx.destination);

      // subtle slow detune (not rhythmic)
      const lfo = audioCtx.createOscillator();
      lfo.type = "sine";
      lfo.frequency.value = 0.03; // very slow
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 4.0;
      lfo.connect(lfoGain);
      lfoGain.connect(osc1.detune);
      lfoGain.connect(osc2.detune);

      osc1.start(); osc2.start(); noiseSrc.start(); lfo.start();
    }

    async function enter(){
      await setupAudio();
      await audioCtx.resume();
      audioOn = true;
      master.gain.cancelScheduledValues(audioCtx.currentTime);
      master.gain.linearRampToValueAtTime(muted ? 0 : 0.9, audioCtx.currentTime + 0.8);
    }

    function toggleMute(){
      muted = !muted;
      document.getElementById("silence").textContent = muted ? "音あり" : "無音";
      if(audioCtx && master){
        master.gain.cancelScheduledValues(audioCtx.currentTime);
        master.gain.linearRampToValueAtTime(muted ? 0 : (audioOn ? 0.9 : 0), audioCtx.currentTime + 0.25);
      }
    }

    // --- Visual field (no clocks, no counters) ---
    const stars = Array.from({length: 1200}, ()=>({
      x: Math.random()*2-1,
      y: Math.random()*2-1,
      z: Math.random(),
      s: Math.random()*1+0.15,
      k: Math.random()*Math.PI*2
    }));

    // “timeless” internal motion: not linear time; quasi drift
    let phase = 0;
    function drift(){
      // no fixed dt; derives from micro variation
      phase += 0.0035 + (Math.sin(phase*0.7)*0.0006);
      return phase;
    }

    function draw(){
      // smooth pointer
      spx += (px-spx)*0.05;
      spy += (py-spy)*0.05;

      const cx = (spx-0.5)*2;
      const cy = (spy-0.5)*2;
      const dist = Math.min(1, Math.hypot(cx,cy));
      // pull is “closeness to center” (no explicit progress)
      const pull = (1 - dist);
      // soften response so it feels viscous
      const p = Math.pow(Math.max(0, pull), 1.35);

      // background
      const centerX = W/2, centerY = H/2;
      const bg = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(W,H)*0.78);
      bg.addColorStop(0, "rgb(10,12,20)");
      bg.addColorStop(1, "rgb(0,0,0)");
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,W,H);

      // starfield swirl (uses drift phase)
      const ph = drift();

      ctx.save();
      ctx.translate(centerX, centerY);
      const zoom = 0.68 + 1.55*p;
      ctx.scale(zoom, zoom);

      const base = Math.min(W,H)*0.48;
      for(const st of stars){
        const ang0 = Math.atan2(st.y, st.x);
        const r0 = Math.hypot(st.x, st.y);

        // swirl intensity grows near center; motion is not “time-based” in a readable way
        const swirl = (0.11 + 0.85*p) * (1/(0.16 + r0)) * 0.09;
        const a = ang0 + (Math.sin(ph + st.k)*0.6 + ph)*swirl*6.0;

        // in-fall without a “progress” feeling
        const fall = (0.10 + 0.88*(1-st.z)) * p * 0.45;
        const r = Math.max(0.02, r0 - fall);

        const x = Math.cos(a)*r;
        const y = Math.sin(a)*r;

        const sx = x * base;
        const sy = y * base;

        const size = (st.s * (0.55 + 2.4*p)) * DPR;
        const alpha = 0.14 + 0.86*(1 - st.z);

        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.fillRect(sx, sy, size, size);
      }
      ctx.restore();

      // event horizon
      const rH = Math.min(W,H) * (0.055 + 0.070*p);
      const ring = ctx.createRadialGradient(centerX, centerY, rH*0.25, centerX, centerY, rH*2.8);
      ring.addColorStop(0, "rgba(0,0,0,1)");
      ring.addColorStop(0.55, "rgba(0,0,0,1)");
      ring.addColorStop(0.82, `rgba(180,200,255,${0.08 + 0.46*p})`);
      ring.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = ring;
      ctx.beginPath();
      ctx.arc(centerX, centerY, rH*3.0, 0, Math.PI*2);
      ctx.fill();

      // vignette (timeless: reduces cues)
      const vg = ctx.createRadialGradient(centerX, centerY, Math.min(W,H)*0.15, centerX, centerY, Math.max(W,H)*0.80);
      vg.addColorStop(0, "rgba(0,0,0,0)");
      vg.addColorStop(0.55, `rgba(0,0,0,${0.10 + 0.30*p})`);
      vg.addColorStop(1, `rgba(0,0,0,${0.62 + 0.28*p})`);
      ctx.fillStyle = vg;
      ctx.fillRect(0,0,W,H);

      // audio reacts to “center closeness” but not rhythmically
      if(audioCtx && audioOn){
        // darker + quieter near center, as if the world loses edges
        const f = 1000*(0.35 + 0.65*(1-p));
        lp.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.20);
      }

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);

    // --- UI actions ---
    const overlay = document.getElementById("overlay");
    document.getElementById("enter").addEventListener("click", async ()=>{
      await enter();
      // gently reduce UI dominance after entry
      overlay.classList.add("fade");
      setTimeout(()=>{ overlay.style.display="none"; }, 1400);
    });
    document.getElementById("silence").addEventListener("click", toggleMute);
    document.getElementById("vanish").addEventListener("click", ()=>{
      overlay.classList.add("fade");
      setTimeout(()=>{ overlay.style.display="none"; }, 1400);
    });
  </script>
</body>
</html>
